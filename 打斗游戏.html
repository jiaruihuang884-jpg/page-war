<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Dodge - æ‰‹ç»˜èº²é¿</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è®¾ç½® Inter å­—ä½“ -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* å¤–éƒ¨èƒŒæ™¯ */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: #F8F4E3; /* æ¨¡æ‹Ÿç±³è‰²ç¬”è®°æœ¬çº¸å¼  */
            border: 5px solid #1f2937; /* æ¨¡æ‹Ÿç¬”è®°æœ¬å¤–å£³/ç²—æè¾¹ */
            border-radius: 8px;
            touch-action: none; /* ç¦ç”¨é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }
        /* éšè—å³é”®èœå•ä»¥æ”¯æŒå³é”®è·³è·ƒ */
        canvas:not(.game-over) {
            cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M12 19V5m-7 7h14'/%3E%3C/svg%3E"), auto;
        }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="game-container" class="flex flex-col items-center">
    <div id="ui-overlay" class="absolute inset-0 flex flex-col justify-between p-4 pointer-events-none z-10">
        <!-- é¡¶éƒ¨ HUD -->
        <div class="flex justify-between w-full text-gray-800 text-lg font-bold">
            <span id="score-display">åˆ†æ•°: 0</span>
            <span id="ammo-display">å¼¹è¯: 0</span>
            <span id="lives-display">ç”Ÿå‘½: â¤ï¸â¤ï¸â¤ï¸</span>
        </div>

        <!-- æ¸¸æˆçŠ¶æ€ä¿¡æ¯ -->
        <div id="game-status" class="text-center">
            <h1 id="start-title" class="text-4xl font-extrabold text-gray-900 mb-4 tracking-tighter">Doodle Dodge</h1>
            <p id="start-message" class="text-xl text-gray-700 font-medium bg-white/70 backdrop-blur-sm p-2 rounded-lg shadow-md">
                ä½¿ç”¨ â†‘/â†“ åˆ‡æ¢è½¦é“, ç©ºæ ¼/å³é”® è·³è·ƒ, Enter å°„å‡».<br>
                æŒ‰ä»»æ„é”®å¼€å§‹!
            </p>
            <p id="pause-message" class="hidden text-3xl font-extrabold text-gray-900 bg-white/80 backdrop-blur-sm p-3 rounded-xl shadow-lg border-2 border-gray-900">
                æš‚åœ (P)
            </p>
            <div id="game-over-screen" class="hidden bg-red-100/90 backdrop-blur-sm p-8 rounded-xl shadow-2xl border-4 border-red-600">
                <h2 class="text-5xl font-extrabold text-red-700 mb-4">æ¸¸æˆç»“æŸ!</h2>
                <p id="final-score" class="text-2xl text-gray-800 mb-6">æœ€ç»ˆå¾—åˆ†: 0</p>
                <button id="restart-button" class="px-6 py-3 bg-red-500 text-white font-bold text-xl rounded-full shadow-lg hover:bg-red-600 transition duration-150 transform hover:scale-105 pointer-events-auto">
                    é‡æ–°å¼€å§‹ (R)
                </button>
            </div>
        </div>

        <!-- åº•éƒ¨æ§åˆ¶æç¤º -->
        <div class="text-center text-sm text-gray-600/80 font-mono">
            Lane: â†‘/â†“ | Jump: Space/RMB | Shoot: Enter | Pause: P
        </div>
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
</div>

<script type="module">
    // --- Configuration and Global Setup ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 400;
    const LANE_COUNT = 3;
    const LANE_HEIGHT = CANVAS_HEIGHT / LANE_COUNT;
    const DRAW_JITTER = 1; // æŠ–åŠ¨åƒç´ èŒƒå›´
    const STROKE_COUNT = 2; // æè¾¹æ¬¡æ•°
    const BASE_SPEED = 5;
    const GRAVITY = 0.5;

    // é¢œè‰²é…ç½®ï¼Œæ¨¡æ‹Ÿæ‰‹ç»˜ç¬”è¿¹
    const COLORS = {
        INK: '#1f2937', // æ·±ç°/å¢¨æ°´è‰²
        PAPER: '#F8F4E3',
        MARGIN: '#EF4444', // çº¢è‰²è¾¹æ³¨çº¿
        LINE: '#93C5FD', // æ·¡è“è‰²æ¨ªçº¿
        ENEMY: '#DC2626', // çº¢è‰²éšœç¢
        PLAYER: '#1f2937',
        AMMO: '#FCD34D', // é»„è‰²é“å…·
        HEART: '#F97316', // æ©™è‰²é“å…·
        PENCIL_TIP: '#000000',
        PENCIL_BODY: '#FBBF24',
        PENCIL_WOOD: '#92400E',
    };

    let canvas, ctx;
    let game = {
        state: 'START', // START, RUNNING, PAUSED, GAME_OVER
        speed: BASE_SPEED,
        score: 0,
        lastTime: 0,
        deltaTime: 0,
        isPaused: false,
        shakeDuration: 0,
        shakeIntensity: 0,
        nextObstacleTime: 0,
        obstacleInterval: 1500, // ms
    };

    let player = {
        lane: 1, // 0: Top, 1: Middle, 2: Bottom
        x: 100,
        y: 0, // Current Y position (relative to lane ground)
        yVelocity: 0,
        isJumping: false,
        jumpApexY: 60, // è·³è·ƒé«˜åº¦
        lives: 3,
        ammo: 0,
        hitCooldown: 0,
    };

    let obstacles = [];
    let audioController;
    let pencilGenerator;

    // --- Utility Functions ---

    /**
     * @description æ¨¡æ‹Ÿä¸å®Œç¾çš„ã€æ‰‹ç»˜å¢¨æ°´çº¿æ¡æ•ˆæœçš„è·¯å¾„ç»˜åˆ¶ã€‚
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array<{x: number, y: number}>} path
     * @param {string} color
     * @param {number} lineWidth
     * @param {boolean} fill
     */
    function drawSketchyPath(ctx, path, color, lineWidth, fill = false) {
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = lineWidth;
        const jitter = DRAW_JITTER;
        const strokeCount = STROKE_COUNT;

        for (let i = 0; i < strokeCount; i++) {
            ctx.beginPath();
            let startX = path[0].x + (Math.random() * 2 - 1) * jitter;
            let startY = path[0].y + (Math.random() * 2 - 1) * jitter;
            ctx.moveTo(startX, startY);

            for (let j = 1; j < path.length; j++) {
                let x = path[j].x + (Math.random() * 2 - 1) * jitter;
                let y = path[j].y + (Math.random() * 2 - 1) * jitter;
                ctx.lineTo(x, y);
            }

            if (fill) {
                ctx.closePath();
                ctx.fill();
            } else {
                if (path[path.length - 1].x === path[0].x && path[path.length - 1].y === path[0].y) {
                    ctx.closePath();
                }
                ctx.stroke();
            }
        }
    }

    /**
     * @description ç»˜åˆ¶ç²’å­çˆ†ç‚¸æ•ˆæœ
     * @param {object} particle
     */
    function drawParticle(p) {
        drawSketchyPath(ctx, [
            { x: p.x - p.size / 2, y: p.y - p.size / 2 },
            { x: p.x + p.size / 2, y: p.y - p.size / 2 },
            { x: p.x + p.size / 2, y: p.y + p.size / 2 },
            { x: p.x - p.size / 2, y: p.y + p.size / 2 },
        ], p.color, 1, true);
    }

    // --- Game Entities and Classes ---

    /**
     * @description åŸºç¡€æ¸¸æˆå¯¹è±¡ç±»
     * @param {number} x
     * @param {number} lane
     * @param {string} type
     * @param {boolean} isGround - æ˜¯å¦ä¸ºåœ°é¢éšœç¢ (å¯é€šè¿‡è·³è·ƒé¿å¼€)
     * @param {number} width
     * @param {number} height
     */
    class GameObject {
        constructor(x, lane, type, isGround, width, height) {
            this.x = x;
            this.lane = lane;
            this.type = type;
            this.isGround = isGround;
            this.width = width;
            this.height = height;
            this.yOffset = 0; // ç”¨äºç©ºä¸­éšœç¢
            this.color = COLORS.ENEMY;
            this.isCollidable = true;
            this.isDrawing = true; // é“…ç¬”ç”Ÿæˆæœºåˆ¶
            this.isDestroyable = ['Eraser', 'PaperPlane'].includes(type);

            if (type === 'PaperPlane') {
                this.yOffset = -50;
                this.color = COLORS.INK;
            } else if (type === 'AmmoPack') {
                this.color = COLORS.AMMO;
                this.isCollidable = false;
                this.isGround = true;
            } else if (type === 'Heart') {
                this.color = COLORS.HEART;
                this.isCollidable = false;
                this.isGround = true;
            } else if (type === 'Eraser') {
                this.isMovable = true;
                this.moveSpeed = 0.5;
            }
        }

        get groundY() {
            return (this.lane + 1) * LANE_HEIGHT - LANE_HEIGHT / 2 + this.yOffset;
        }

        update(deltaTime) {
            if (this.isDrawing) return;

            this.x -= game.speed * (deltaTime / 16);

            if (this.isMovable) {
                // æ©¡çš®æ“¦ (Eraser) ä¼šä¸»åŠ¨å‘ç©å®¶ç§»åŠ¨
                if (this.type === 'Eraser' && player.x + player.width < this.x) {
                     this.x -= this.moveSpeed * (deltaTime / 16);
                }
            }

            // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå±å¹•
            if (this.x < -this.width) {
                return true; // è¡¨ç¤ºå¯ä»¥è¢«ç§»é™¤
            }
            return false;
        }

        draw(ctx) {
            const path = [];
            const x = this.x;
            const y = this.groundY;
            let fill = !this.isDrawing;

            // ç»˜åˆ¶ç‰©ä½“
            switch (this.type) {
                case 'Stone':
                    // ç®€å•çš„åœ†å½¢/çŸ³å¤´
                    ctx.beginPath();
                    ctx.arc(x, y, 15, 0, Math.PI * 2);
                    if (fill) ctx.fill(); else ctx.stroke();
                    drawSketchyPath(ctx, [{x:x-10, y:y+5}, {x:x+10, y:y-5}, {x:x-5, y:y-10}], this.color, 2, false);
                    break;
                case 'Spikes':
                    // å°–åˆº
                    path.push({ x: x - 15, y: y }, { x: x, y: y - 30 }, { x: x + 15, y: y });
                    drawSketchyPath(ctx, path, this.color, 3, fill);
                    break;
                case 'Hole':
                    // å‘æ´ (ç»˜åˆ¶ä¸€ä¸ªåœ°é¢è£‚ç¼)
                    path.push(
                        { x: x - 25, y: y + 10 },
                        { x: x - 10, y: y + 5 },
                        { x: x + 10, y: y + 15 },
                        { x: x + 25, y: y + 10 }
                    );
                    drawSketchyPath(ctx, path, COLORS.INK, 2, false);
                    this.isCollidable = true; // å‘æ´å¿…é¡»è·³è¿‡
                    this.isGround = true;
                    fill = false; // å‘æ´æ°¸è¿œä¸å¡«å……
                    break;
                case 'PaperPlane':
                    // çº¸é£æœº (ç©ºä¸­éšœç¢)
                    path.push(
                        { x: x - 25, y: y }, { x: x + 10, y: y - 5 }, { x: x + 25, y: y }, { x: x + 10, y: y + 5 }, { x: x - 25, y: y }
                    );
                    drawSketchyPath(ctx, path, this.color, 2, fill);
                    break;
                case 'Ruler':
                    // å°ºå­/é«˜å¢™ (éœ€æ¢é“)
                    path.push(
                        { x: x - 5, y: y + 50 }, { x: x + 5, y: y + 50 }, { x: x + 5, y: y - 50 }, { x: x - 5, y: y - 50 }, { x: x - 5, y: y + 50 }
                    );
                    drawSketchyPath(ctx, path, COLORS.INK, 5, fill);
                    break;
                case 'Eraser':
                    // æ©¡çš®æ“¦ (ç§»åŠ¨æ•Œäºº)
                    path.push(
                        { x: x - 20, y: y - 10 }, { x: x + 20, y: y - 10 }, { x: x + 20, y: y + 10 }, { x: x - 20, y: y + 10 }
                    );
                    drawSketchyPath(ctx, path, COLORS.ENEMY, 3, fill);
                    drawSketchyPath(ctx, [{x: x - 15, y: y}, {x: x + 15, y: y}], COLORS.INK, 1, false); // åˆ†å‰²çº¿
                    break;
                case 'AmmoPack':
                    // å¼¹è¯åŒ… (ç»˜åˆ¶å­å¼¹å›¾æ ‡)
                    path.push(
                        { x: x - 5, y: y - 15 }, { x: x + 5, y: y - 15 }, { x: x + 5, y: y + 15 }, { x: x - 5, y: y + 15 }
                    );
                    drawSketchyPath(ctx, path, this.color, 2, fill);
                    path.push({ x: x, y: y - 20 }, { x: x, y: y + 20 });
                    drawSketchyPath(ctx, path, COLORS.INK, 1, false);
                    break;
                case 'Heart':
                    // ç”Ÿå‘½ä¹‹å¿ƒ (ç»˜åˆ¶æ‰‹ç»˜å¿ƒå½¢)
                    ctx.beginPath();
                    ctx.moveTo(x, y - 5);
                    ctx.bezierCurveTo(x + 10, y - 25, x + 30, y - 5, x, y + 15);
                    ctx.bezierCurveTo(x - 30, y - 5, x - 10, y - 25, x, y - 5);
                    if (fill) ctx.fill(); else ctx.stroke();
                    break;
            }

            // ç¢°æ’åŒºåŸŸ (ä»…ç”¨äºè°ƒè¯•ï¼Œæ­£å¼ç‰ˆä¸ç»˜åˆ¶)
            // if (this.isCollidable) {
            //     const ground = (this.lane + 1) * LANE_HEIGHT;
            //     ctx.strokeStyle = 'rgba(0,0,255,0.5)';
            //     ctx.strokeRect(this.x - this.width / 2, ground - this.height, this.width, this.height);
            // }
        }
    }

    /**
     * @description é“…ç¬”ç”Ÿæˆå™¨ï¼Œè´Ÿè´£â€œç”»å‡ºâ€éšœç¢ç‰©
     */
    class PencilGenerator {
        constructor() {
            this.x = CANVAS_WIDTH + 50;
            this.y = CANVAS_HEIGHT / 2;
            this.targetX = 650;
            this.targetY = 0;
            this.state = 'IDLE'; // IDLE, FLY_IN, DRAWING, FLY_OUT
            this.obstacleToDraw = null;
            this.drawProgress = 0;
            this.drawDuration = 40; // ç»˜åˆ¶å¸§æ•°
        }

        // ç»˜åˆ¶é“…ç¬”
        drawPencil(ctx) {
            const x = this.x;
            const y = this.y;
            const path = [];

            // é“…ç¬”ä¸»ä½“ (é»„è‰²)
            path.push(
                { x: x - 50, y: y - 5 }, { x: x + 50, y: y - 5 },
                { x: x + 50, y: y + 5 }, { x: x - 50, y: y + 5 }
            );
            drawSketchyPath(ctx, path, COLORS.PENCIL_BODY, 1, true);

            // ç¬”å°– (æœ¨å¤´è‰²)
            const tipPath = [
                { x: x + 50, y: y - 5 }, { x: x + 60, y: y }, { x: x + 50, y: y + 5 }
            ];
            drawSketchyPath(ctx, tipPath, COLORS.PENCIL_WOOD, 1, true);

            // ç¬”èŠ¯ (é»‘è‰²)
            const leadPath = [
                { x: x + 60, y: y - 1 }, { x: x + 70, y: y }, { x: x + 60, y: y + 1 }
            ];
            drawSketchyPath(ctx, leadPath, COLORS.PENCIL_TIP, 1, true);

            // æ©¡çš®æ“¦å°¾éƒ¨ (ç²‰è‰²/ç°è‰²)
            const eraserPath = [
                { x: x - 55, y: y - 7 }, { x: x - 50, y: y - 7 },
                { x: x - 50, y: y + 7 }, { x: x - 55, y: y + 7 }
            ];
            drawSketchyPath(ctx, eraserPath, COLORS.ENEMY, 1, true);
        }

        startDrawing(obstacle) {
            this.obstacleToDraw = obstacle;
            this.targetY = obstacle.groundY;
            this.state = 'FLY_IN';
            this.drawProgress = 0;
            this.x = CANVAS_WIDTH + 50;
            this.y = CANVAS_HEIGHT / 2;
        }

        update(deltaTime) {
            if (this.state === 'IDLE') return;

            if (this.state === 'FLY_IN') {
                // å¿«é€Ÿé£å…¥åˆ°ç»˜åˆ¶ä½ç½®
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5) {
                    this.state = 'DRAWING';
                    this.x = this.targetX;
                    this.y = this.targetY;
                } else {
                    this.x += dx * 0.15;
                    this.y += dy * 0.15;
                }
            } else if (this.state === 'DRAWING') {
                this.drawProgress++;
                // ç»˜åˆ¶è¿‡ç¨‹
                if (this.obstacleToDraw) {
                    // åœ¨ç»˜åˆ¶é˜¶æ®µï¼Œéšœç¢ç‰©åªæè¾¹
                    this.obstacleToDraw.isDrawing = true;

                    // è¾¾åˆ°ç»˜åˆ¶å¸§æ•°åï¼Œè½¬ä¸ºå®ä½“ï¼Œé“…ç¬”é£èµ°
                    if (this.drawProgress >= this.drawDuration) {
                        this.obstacleToDraw.isDrawing = false;
                        this.obstacleToDraw = null;
                        this.state = 'FLY_OUT';
                    }
                }
            } else if (this.state === 'FLY_OUT') {
                // å¿«é€Ÿé£å‡ºå±å¹•
                this.x -= game.speed * 2 * (deltaTime / 16);
                if (this.x < -100) {
                    this.state = 'IDLE';
                }
            }
        }
    }

    /**
     * @description ç©å®¶ç«æŸ´äººç»˜åˆ¶å’Œé€»è¾‘
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y - ç›¸å¯¹äºåœ°é¢çº¿çš„åç§»
     * @param {number} phase - è·‘åŠ¨åŠ¨ç”»ç›¸ä½ (0-2*PI)
     * @param {boolean} isJumping
     */
    function drawStickman(ctx, x, y, phase, isJumping, isInvincible) {
        const bodyHeight = 35;
        const headRadius = 10;
        const groundY = (player.lane + 1) * LANE_HEIGHT + y; // å®é™…Yåæ ‡

        // å¤´éƒ¨
        ctx.beginPath();
        ctx.arc(x, groundY - bodyHeight - headRadius, headRadius, 0, Math.PI * 2);
        drawSketchyPath(ctx, [{x: x, y: groundY - bodyHeight - headRadius}], COLORS.PLAYER, 2, false);

        // èº«ä½“
        const bodyStart = { x: x, y: groundY - bodyHeight };
        const bodyEnd = { x: x, y: groundY };
        drawSketchyPath(ctx, [bodyStart, bodyEnd], COLORS.PLAYER, 2, false);

        // è‚¢ä½“åŠ¨ç”»
        const limbLength = 20;
        const swingAngle = Math.sin(phase) * 0.5;

        let leftArm, rightArm, leftLeg, rightLeg;

        if (isJumping) {
            // è·³è·ƒæ—¶çš„æ”¶è…¿/æ”¶è‡‚åŠ¨ä½œ
            const armOffset = Math.PI / 4;
            leftArm = [bodyStart, { x: x - limbLength * Math.cos(armOffset), y: bodyStart.y + limbLength * Math.sin(armOffset) }];
            rightArm = [bodyStart, { x: x + limbLength * Math.cos(armOffset), y: bodyStart.y + limbLength * Math.sin(armOffset) }];

            const legOffset = Math.PI / 3;
            leftLeg = [bodyEnd, { x: x - limbLength * Math.cos(legOffset), y: bodyEnd.y + limbLength * Math.sin(legOffset) }];
            rightLeg = [bodyEnd, { x: x + limbLength * Math.cos(legOffset), y: bodyEnd.y + limbLength * Math.sin(legOffset) }];

        } else {
            // è·‘åŠ¨æ—¶çš„æ­£å¼¦æ³¢æ‘†åŠ¨
            // å³è‡‚ (å‰æ‘†), å·¦è‡‚ (åæ‘†)
            rightArm = [bodyStart, { x: x + limbLength * Math.sin(swingAngle), y: bodyStart.y + limbLength * Math.cos(swingAngle) }];
            leftArm = [bodyStart, { x: x + limbLength * Math.sin(swingAngle - Math.PI), y: bodyStart.y + limbLength * Math.cos(swingAngle - Math.PI) }];

            // å·¦è…¿ (å‰è¸¢), å³è…¿ (åè¹¬) - ç›¸ä½ç›¸å
            leftLeg = [bodyEnd, { x: x + limbLength * Math.sin(phase + 0.3), y: bodyEnd.y + limbLength * Math.cos(phase + 0.3) }];
            rightLeg = [bodyEnd, { x: x + limbLength * Math.sin(phase - Math.PI + 0.3), y: bodyEnd.y + limbLength * Math.cos(phase - Math.PI + 0.3) }];
        }

        // ç»˜åˆ¶å››è‚¢
        drawSketchyPath(ctx, leftArm, COLORS.PLAYER, 2, false);
        drawSketchyPath(ctx, rightArm, COLORS.PLAYER, 2, false);
        drawSketchyPath(ctx, leftLeg, COLORS.PLAYER, 2, false);
        drawSketchyPath(ctx, rightLeg, COLORS.PLAYER, 2, false);

        // ç»˜åˆ¶æ— æ•Œæ—¶çš„é—ªçƒæ•ˆæœ
        if (isInvincible && Math.floor(game.lastTime / 100) % 2 === 0) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
            ctx.fillRect(x - 20, groundY - 50, 40, 50);
        }

        // æ›´æ–°ç¢°æ’ç›’å°ºå¯¸ (ç”¨äºç®€æ˜“ç¢°æ’æ£€æµ‹)
        player.width = 20;
        player.height = bodyHeight + headRadius;
    }

    /**
     * @description ç²’å­æ•ˆæœç³»ç»Ÿ
     */
    const particles = [];

    function createExplosion(x, y, color) {
        audioController.playImpact();
        for (let i = 0; i < 15; i++) {
            particles.push({
                x: x,
                y: y,
                color: color,
                size: Math.random() * 8 + 4,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8 - 2,
                life: 60, // å¸§æ•°
                gravity: 0.3,
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += p.gravity;
            p.life--;

            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    // --- Audio Controller (Web Audio API) ---

    class AudioController {
        constructor() {
            try {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('Web Audio API is not supported in this browser.');
                this.audioCtx = null;
            }
        }

        // åˆ›å»ºåŸºç¡€éŸ³æ•ˆ (æŒ¯è¡å™¨, å¢ç›Š, æ’­æ”¾æ—¶é—´)
        makeSound(freq, type, duration, volume = 0.5, attack = 0.01, release = 0.1) {
            if (!this.audioCtx) return;

            const oscillator = this.audioCtx.createOscillator();
            const gainNode = this.audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioCtx.destination);

            oscillator.type = type; // 'sine', 'square', 'sawtooth', 'triangle'
            oscillator.frequency.setValueAtTime(freq, this.audioCtx.currentTime);

            // åŒ…ç»œ (Envelope)
            gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, this.audioCtx.currentTime + attack);
            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + attack + release);

            oscillator.start();
            oscillator.stop(this.audioCtx.currentTime + duration);
        }

        // 1. è·³è·ƒ (é¢‘ç‡çˆ¬å‡çš„æ–¹æ³¢)
        playJump() {
            if (!this.audioCtx) return;
            const now = this.audioCtx.currentTime;
            const oscillator = this.audioCtx.createOscillator();
            const gainNode = this.audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioCtx.destination);

            oscillator.type = 'square';
            gainNode.gain.setValueAtTime(0.3, now);

            // é¢‘ç‡ä» 200Hz çˆ¬å‡åˆ° 500Hz
            oscillator.frequency.setValueAtTime(200, now);
            oscillator.frequency.linearRampToValueAtTime(500, now + 0.2);

            oscillator.start(now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
            oscillator.stop(now + 0.25);
        }

        // 2. å°„å‡» (çŸ­ä¿ƒçš„é«˜é¢‘ä¸‰è§’æ³¢)
        playShoot() {
            this.makeSound(800, 'triangle', 0.1, 0.4, 0.01, 0.05);
        }

        // 3. æ’å‡»/çˆ†ç‚¸ (å™ªæ³¢çˆ†å‘)
        playImpact() {
            if (!this.audioCtx) return;
            const now = this.audioCtx.currentTime;
            const bufferSize = this.audioCtx.sampleRate * 0.2; // 0.2s å™ªéŸ³
            const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1; // éšæœºå™ªéŸ³
            }

            const noise = this.audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gainNode = this.audioCtx.createGain();

            noise.connect(gainNode);
            gainNode.connect(this.audioCtx.destination);

            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

            noise.start(now);
            noise.stop(now + 0.2);
        }

        // 4. æ‹¾å–é“å…· (åŒéŸ³é˜¶æç¤ºéŸ³)
        playPickup() {
            if (!this.audioCtx) return;
            const now = this.audioCtx.currentTime;
            this.makeSound(440, 'sine', 0.08, 0.3); // A4
            setTimeout(() => this.makeSound(660, 'sine', 0.08, 0.3), 80); // E5
        }

        // 5. æ¸¸æˆç»“æŸ (é¢‘ç‡ä¸‹é™çš„é”¯é½¿æ³¢)
        playGameOver() {
            if (!this.audioCtx) return;
            const now = this.audioCtx.currentTime;
            const oscillator = this.audioCtx.createOscillator();
            const gainNode = this.audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioCtx.destination);

            oscillator.type = 'sawtooth';
            gainNode.gain.setValueAtTime(0.5, now);

            // é¢‘ç‡ä» 300Hz ä¸‹é™åˆ° 100Hz
            oscillator.frequency.setValueAtTime(300, now);
            oscillator.frequency.linearRampToValueAtTime(100, now + 1.0);

            oscillator.start(now);
            gainNode.gain.linearRampToValueAtTime(0, now + 1.0);
            oscillator.stop(now + 1.0);
        }
    }

    // --- Game Logic ---

    function initGame() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        audioController = new AudioController();
        pencilGenerator = new PencilGenerator();

        // ç¡®ä¿ canvas å°ºå¯¸æ­£ç¡®
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        document.addEventListener('keydown', handleInput);
        document.addEventListener('mousedown', handleMouseDown);

        // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
        resetGame();
        // é¦–æ¬¡åŠ è½½ï¼Œæ˜¾ç¤ºå¼€å§‹ç•Œé¢
        updateUI();

        window.requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        player.lane = 1;
        player.y = 0;
        player.yVelocity = 0;
        player.isJumping = false;
        player.lives = 3;
        player.ammo = 0;
        player.hitCooldown = 0;
        player.width = 20;
        player.height = 45; // é‡æ–°åˆå§‹åŒ–ç¢°æ’ç›’

        game.score = 0;
        game.speed = BASE_SPEED;
        game.state = 'START';
        obstacles = [];
        particles.length = 0;
        pencilGenerator.state = 'IDLE';
        game.nextObstacleTime = 0;

        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('start-title').classList.remove('hidden');
        document.getElementById('start-message').classList.remove('hidden');
        document.getElementById('pause-message').classList.add('hidden');
    }

    function startGame() {
        if (game.state === 'START' || game.state === 'GAME_OVER') {
            game.state = 'RUNNING';
            game.lastTime = performance.now();
            document.getElementById('start-title').classList.add('hidden');
            document.getElementById('start-message').classList.add('hidden');
            updateUI();
        }
    }

    function togglePause() {
        if (game.state === 'RUNNING') {
            game.state = 'PAUSED';
            document.getElementById('pause-message').classList.remove('hidden');
        } else if (game.state === 'PAUSED') {
            game.state = 'RUNNING';
            game.lastTime = performance.now(); // é‡ç½®æ—¶é—´ä»¥é˜²æ­¢è·³å˜
            document.getElementById('pause-message').classList.add('hidden');
        }
        updateUI();
    }

    function gameOver() {
        game.state = 'GAME_OVER';
        audioController.playGameOver();
        document.getElementById('final-score').textContent = `æœ€ç»ˆå¾—åˆ†: ${game.score}`;
        document.getElementById('game-over-screen').classList.remove('hidden');
        canvas.classList.add('game-over');
    }

    // --- Input Handling ---

    function handleInput(event) {
        if (game.state === 'GAME_OVER' && event.key === 'r') {
            resetGame();
            startGame();
            return;
        }

        if (game.state === 'START') {
            startGame();
            return;
        }

        if (game.state === 'RUNNING' || game.state === 'PAUSED') {
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
                return;
            }
        }

        if (game.state !== 'RUNNING') return;

        switch (event.key) {
            case 'ArrowUp':
                player.lane = Math.max(0, player.lane - 1);
                audioController.playPickup(); // æ¢é“éŸ³æ•ˆ
                break;
            case 'ArrowDown':
                player.lane = Math.min(LANE_COUNT - 1, player.lane + 1);
                audioController.playPickup(); // æ¢é“éŸ³æ•ˆ
                break;
            case ' ': // Spacebar for Jump
                event.preventDefault(); // é˜»æ­¢ç©ºæ ¼é”®æ»šåŠ¨é¡µé¢
            case 'ArrowRight': // Right Arrow for Jump (as per prompt example)
                if (!player.isJumping) {
                    player.isJumping = true;
                    // è®¡ç®—åˆå§‹è·³è·ƒé€Ÿåº¦ (V = sqrt(2 * G * H))
                    player.yVelocity = -Math.sqrt(2 * GRAVITY * player.jumpApexY * 2.5);
                    audioController.playJump();
                }
                break;
            case 'Enter':
                if (player.ammo > 0) {
                    player.ammo--;
                    shootBullet();
                    audioController.playShoot();
                }
                break;
        }
        updateUI();
    }

    function handleMouseDown(event) {
        if (game.state === 'START') {
            startGame();
            return;
        }
        if (game.state !== 'RUNNING') return;

        if (event.button === 2) { // Right Click (RMB)
            event.preventDefault();
            if (!player.isJumping) {
                player.isJumping = true;
                player.yVelocity = -Math.sqrt(2 * GRAVITY * player.jumpApexY * 2.5);
                audioController.playJump();
            }
        }
    }

    function shootBullet() {
        // å­å¼¹å°±æ˜¯ä¸€ä¸ªç®€å•çš„ GameObjectï¼Œæ‹¥æœ‰é«˜é€Ÿå’Œé”€æ¯èƒ½åŠ›
        const bullet = new GameObject(player.x + 10, player.lane, 'Bullet', false, 5, 5);
        bullet.color = COLORS.ENEMY; // å­å¼¹é¢œè‰²
        bullet.isDrawing = false; // å­å¼¹ä¸éœ€è¦é“…ç¬”ç»˜åˆ¶
        bullet.isBullet = true;
        bullet.speedMultiplier = 2;
        bullet.update = function(deltaTime) {
            this.x += game.speed * this.speedMultiplier * (deltaTime / 16);
            if (this.x > CANVAS_WIDTH) return true;
            return false;
        };
        obstacles.push(bullet);
    }


    // --- Game Update Logic ---

    function update(deltaTime) {
        if (game.state !== 'RUNNING') return;

        // 1. æ›´æ–°ç©å®¶è·³è·ƒ
        if (player.isJumping) {
            player.y += player.yVelocity * (deltaTime / 16);
            player.yVelocity += GRAVITY * (deltaTime / 16);

            // è½åœ°æ£€æµ‹ (Y è½´å›åˆ°åœ°é¢)
            if (player.y >= 0) {
                player.y = 0;
                player.isJumping = false;
                player.yVelocity = 0;
            }
        }

        // 2. æ›´æ–°å†·å´æ—¶é—´
        if (player.hitCooldown > 0) {
            player.hitCooldown -= deltaTime;
            if (player.hitCooldown < 0) player.hitCooldown = 0;
        }
        if (game.shakeDuration > 0) {
            game.shakeDuration -= deltaTime;
        }

        // 3. æ›´æ–°éšœç¢ç‰©å’Œå­å¼¹
        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obj = obstacles[i];

            if (obj.isDrawing) continue; // æ­£åœ¨ç»˜åˆ¶çš„éšœç¢ç‰©ä¸ç§»åŠ¨

            // å­å¼¹/éšœç¢ç‰©ç¢°æ’æ£€æµ‹
            if (obj.isBullet) {
                // å­å¼¹åªä¸å¯æ‘§æ¯çš„éšœç¢ç‰©ç¢°æ’
                for (let j = 0; j < obstacles.length; j++) {
                    const target = obstacles[j];
                    if (target.isDestroyable && !target.isDrawing && checkCollision(obj, target)) {
                        createExplosion(target.x, target.groundY, target.color);
                        obstacles.splice(i, 1); // ç§»é™¤å­å¼¹
                        obstacles.splice(j, 1); // ç§»é™¤ç›®æ ‡
                        game.score += 50;
                        updateUI();
                        break;
                    }
                }
            } else if (obj.isCollidable) {
                // ç©å®¶ä¸éšœç¢ç‰©ç¢°æ’
                if (checkCollision(player, obj) && player.hitCooldown === 0) {
                    handlePlayerHit(obj);
                }
            } else {
                // ç©å®¶ä¸é“å…·ç¢°æ’ (éç¢°æ’ä½“)
                if (checkCollision(player, obj)) {
                    handlePickup(obj);
                    obstacles.splice(i, 1);
                }
            }

            // ç§»åŠ¨å¹¶æ£€æŸ¥ç§»é™¤
            if (obj.update(deltaTime)) {
                obstacles.splice(i, 1);
                if (obj.isCollidable) {
                    game.score += 10; // æˆåŠŸèº²é¿å¾—åˆ†
                }
            }
        }

        // 4. æ›´æ–°é“…ç¬”ç”Ÿæˆå™¨
        pencilGenerator.update(deltaTime);

        // 5. ç”Ÿæˆæ–°çš„éšœç¢ç‰©
        game.nextObstacleTime -= deltaTime;
        if (game.nextObstacleTime <= 0 && pencilGenerator.state === 'IDLE') {
            generateObstacle();
            game.nextObstacleTime = game.obstacleInterval + Math.random() * 1000;
            // éšæ—¶é—´åŠ å¿«æ¸¸æˆé€Ÿåº¦ (éš¾åº¦å¢åŠ )
            game.speed = Math.min(15, BASE_SPEED + game.score / 2000);
            game.obstacleInterval = Math.max(1000, 1500 - game.score / 5);
        }

        // 6. æ›´æ–°ç²’å­
        updateParticles();

        // 7. æ›´æ–°åˆ†æ•°
        game.score += 1;
        updateUI();
    }

    /**
     * @description ä¼ª3Dç¢°æ’æ£€æµ‹
     * @param {object} playerObj
     * @param {object} obstacleObj
     */
    function checkCollision(playerObj, obstacleObj) {
        // 1. è½¦é“æ£€æµ‹ (å¿…é¡»åœ¨åŒä¸€è½¦é“)
        if (playerObj.lane !== obstacleObj.lane) {
            // Ruler éšœç¢ç‰©ä¾‹å¤–ï¼Œå®ƒå æ®äº†å‚ç›´ç©ºé—´ï¼Œä½†ç©å®¶åªèƒ½åœ¨åŒä¸€è½¦é“è¢«æ£€æµ‹åˆ°ã€‚
            // æ¢é“æ˜¯å”¯ä¸€èº²é¿æ–¹å¼ï¼Œæ‰€ä»¥å®ƒåªæ£€æµ‹è½¦é“ã€‚
        }

        // 2. æ°´å¹³ X è½´æ£€æµ‹ (ç®€å•çŸ©å½¢é‡å )
        const playerX = playerObj.x - playerObj.width / 2;
        const playerW = playerObj.width;
        const obstacleX = obstacleObj.x - obstacleObj.width / 2;
        const obstacleW = obstacleObj.width;

        if (playerX + playerW < obstacleX || playerX > obstacleX + obstacleW) {
            return false;
        }

        // 3. é«˜åº¦/Y/Z è½´æ£€æµ‹ (æ›´å¤æ‚çš„è§„åˆ™)
        const playerGroundY = (playerObj.lane + 1) * LANE_HEIGHT;
        const obstacleGroundY = (obstacleObj.lane + 1) * LANE_HEIGHT;

        // ç©å®¶çš„å®é™…ç¢°æ’é¡¶éƒ¨Yåæ ‡ (Y < 0 æ—¶ä¸ºè·³è·ƒçŠ¶æ€)
        const playerBottom = playerGroundY + playerObj.y;
        const playerTop = playerBottom - playerObj.height;

        // éšœç¢ç‰©çš„å®é™…ç¢°æ’é¡¶éƒ¨Yåæ ‡
        const obstacleBottom = obstacleGroundY + obstacleObj.yOffset;
        const obstacleTop = obstacleBottom - obstacleObj.height;

        // å‚ç›´ç¢°æ’ï¼šåº•éƒ¨é‡å ä¸”é¡¶éƒ¨é‡å 
        if (playerTop > obstacleBottom || playerBottom < obstacleTop) {
            return false;
        }

        // 4. ç‰¹æ®Šç¢°æ’è§„åˆ™ (æ ¹æ®éšœç¢ç‰©ç±»å‹)
        if (obstacleObj.type === 'Hole') {
            // å‘æ´ (Hole): åªæœ‰å½“ç©å®¶åœ¨åœ°é¢ä¸Š (player.y === 0) æ‰ä¼šè§¦å‘ç¢°æ’
            if (playerObj.y === 0) {
                return true;
            }
            return false;
        }

        if (!obstacleObj.isGround) {
            // ç©ºä¸­éšœç¢ (PaperPlane): åªæœ‰å½“ç©å®¶è·³è·ƒæ—¶æ‰å®¹æ˜“æ’ä¸Š
            // åªæœ‰å½“ç©å®¶è·³è·ƒ (y < 0) ä¸”å‚ç›´ä½ç½®åŒ¹é…æ—¶æ‰åˆ¤å®šç¢°æ’
            if (playerObj.y < 0 && playerBottom > obstacleTop) {
                return true;
            }
            return false;
        }

        // åœ°é¢éšœç¢ (Stone, Spikes, Eraser, Ruler): ç©å®¶å¿…é¡»è·³è·ƒæˆ–æ¢é“é¿å¼€
        return true;
    }

    function handlePlayerHit(obstacle) {
        player.lives--;
        player.hitCooldown = 1500; // 1.5ç§’æ— æ•Œ
        game.shakeDuration = 200;
        game.shakeIntensity = 5;

        audioController.playImpact();
        createExplosion(player.x, (player.lane + 1) * LANE_HEIGHT - 20, COLORS.ENEMY);

        if (player.lives <= 0) {
            gameOver();
        }
        updateUI();
    }

    function handlePickup(item) {
        audioController.playPickup();
        if (item.type === 'AmmoPack') {
            player.ammo += 5;
        } else if (item.type === 'Heart') {
            player.lives = Math.min(3, player.lives + 1);
        }
        updateUI();
    }

    function generateObstacle() {
        const lane = Math.floor(Math.random() * LANE_COUNT);
        let newObj;

        const choice = Math.random();
        let type;

        if (choice < 0.2) type = 'Stone';
        else if (choice < 0.35) type = 'Spikes';
        else if (choice < 0.5) type = 'Hole';
        else if (choice < 0.65) type = 'PaperPlane';
        else if (choice < 0.75) type = 'Ruler';
        else if (choice < 0.85) type = 'Eraser';
        else if (choice < 0.95) type = (Math.random() < 0.5) ? 'AmmoPack' : 'Heart';
        else type = 'Stone'; // é»˜è®¤

        let isGround = !['PaperPlane'].includes(type);
        let width = 30;
        let height = 30;
        if (type === 'Ruler') height = 100;
        if (type === 'Hole') { width = 50; height = 10; }
        if (type === 'Eraser') { width = 40; height = 20; }
        if (type === 'AmmoPack' || type === 'Heart') { width = 20; height = 20; }

        newObj = new GameObject(CANVAS_WIDTH + 50, lane, type, isGround, width, height);
        obstacles.push(newObj);
        pencilGenerator.startDrawing(newObj);
    }

    // --- Drawing Functions ---

    function drawBackground(ctx) {
        // ç»˜åˆ¶ç¬”è®°æœ¬çº¸å¼ èƒŒæ™¯çº¿
        ctx.save();
        ctx.translate(game.shakeDuration > 0 ? (Math.random() * game.shakeIntensity - game.shakeIntensity / 2) : 0, 0);

        // 1. æ·¡è“è‰²æ¨ªçº¿ (æ¨¡æ‹Ÿçº¸å¼ çº¿æ¡)
        const lineSpacing = 20;
        ctx.strokeStyle = COLORS.LINE;
        ctx.lineWidth = 1;
        for (let i = 0; i < CANVAS_HEIGHT / lineSpacing; i++) {
            const y = i * lineSpacing;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(CANVAS_WIDTH, y);
            ctx.stroke();
        }

        // 2. çº¢è‰²ç«–å‘è¾¹æ³¨çº¿ (æ¨¡æ‹Ÿç¬”è®°æœ¬è¾¹è·)
        const marginX = 80;
        ctx.strokeStyle = COLORS.MARGIN;
        ctx.lineWidth = 3;
        drawSketchyPath(ctx, [{ x: marginX, y: 0 }, { x: marginX, y: CANVAS_HEIGHT }], COLORS.MARGIN, 3, false);

        // 3. ç»˜åˆ¶è½¦é“çº¿ (æ›´ç²—çš„çº¿æ¡)
        ctx.strokeStyle = COLORS.INK;
        ctx.lineWidth = 3;
        for (let i = 1; i < LANE_COUNT; i++) {
            const y = i * LANE_HEIGHT;
            drawSketchyPath(ctx, [{ x: 0, y: y }, { x: CANVAS_WIDTH, y: y }], COLORS.INK, 3, false);
        }

        ctx.restore();
    }

    function drawGameScene(ctx) {
        // æ¸¸æˆè¿è¡Œæ—¶ï¼Œç”»å¸ƒå¯ä»¥è½»å¾®æŠ–åŠ¨ (æ¨¡æ‹Ÿå—ä¼¤)
        ctx.save();
        if (game.shakeDuration > 0) {
            const offsetX = Math.random() * game.shakeIntensity - game.shakeIntensity / 2;
            const offsetY = Math.random() * game.shakeIntensity - game.shakeIntensity / 2;
            ctx.translate(offsetX, offsetY);
        }

        // ç»˜åˆ¶èƒŒæ™¯
        drawBackground(ctx);

        // ç»˜åˆ¶éšœç¢ç‰©
        obstacles.forEach(obj => {
            // æ­£åœ¨ç»˜åˆ¶çš„éšœç¢ç‰©ï¼Œè®©é“…ç¬”æ¥ç»˜åˆ¶
            if (obj.isDrawing && pencilGenerator.obstacleToDraw === obj) {
                // ç»˜åˆ¶æœªå®Œæˆçš„æè¾¹ (å¯é€‰ï¼Œè®©é“…ç¬”ç»˜åˆ¶æ›´æ˜æ˜¾)
                ctx.globalAlpha = pencilGenerator.drawProgress / pencilGenerator.drawDuration;
                obj.draw(ctx);
                ctx.globalAlpha = 1;
            } else {
                obj.draw(ctx);
            }
        });

        // ç»˜åˆ¶é“…ç¬”ç”Ÿæˆå™¨
        pencilGenerator.drawPencil(ctx);

        // ç»˜åˆ¶ç©å®¶ (è·‘åŠ¨åŠ¨ç”»ç›¸ä½)
        const runPhase = (game.lastTime / 100) * game.speed * 0.1;
        drawStickman(ctx, player.x, player.y, runPhase, player.isJumping, player.hitCooldown > 0);

        // ç»˜åˆ¶ç²’å­
        particles.forEach(p => drawParticle(p));

        ctx.restore();
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        if (game.state === 'START' || game.state === 'GAME_OVER') {
            // å¯åŠ¨/ç»“æŸç”»é¢ä¹Ÿéœ€è¦ç»˜åˆ¶èƒŒæ™¯
            drawBackground(ctx);
        } else {
            drawGameScene(ctx);
        }
    }

    function updateUI() {
        document.getElementById('score-display').textContent = `åˆ†æ•°: ${game.score}`;
        document.getElementById('ammo-display').textContent = `å¼¹è¯: ${player.ammo}`;

        let hearts = '';
        for (let i = 0; i < player.lives; i++) {
            hearts += 'â¤ï¸';
        }
        for (let i = player.lives; i < 3; i++) {
            hearts += 'ğŸ¤'; // ç©ºå¿ƒæˆ–ç°è‰²å¿ƒå½¢è¡¨ç¤ºå·²æŸå¤±
        }
        document.getElementById('lives-display').textContent = `ç”Ÿå‘½: ${hearts}`;
    }

    // --- Main Game Loop ---

    function gameLoop(timestamp) {
        const deltaTime = timestamp - game.lastTime;
        game.lastTime = timestamp;
        game.deltaTime = deltaTime;

        if (game.state === 'RUNNING') {
            update(deltaTime);
        } else if (game.state === 'PAUSED') {
            // ä»…æ›´æ–°é“…ç¬”ä½ç½®ï¼Œå› ä¸ºå®ƒä¸éœ€è¦ deltaTime ä¾èµ–
            pencilGenerator.update(deltaTime);
        }

        draw();

        window.requestAnimationFrame(gameLoop);
    }

    // --- Initialization on Load ---
    window.onload = initGame;

    // é‡æ–°å¼€å§‹æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('restart-button').addEventListener('click', () => {
        resetGame();
        startGame();
    });

</script>
</body>
</html>